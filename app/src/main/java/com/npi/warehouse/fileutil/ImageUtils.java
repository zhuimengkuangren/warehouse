package com.npi.warehouse.fileutil;import android.app.Activity;import android.content.ContentUris;import android.content.ContentValues;import android.content.Context;import android.content.Intent;import android.database.Cursor;import android.graphics.Bitmap;import android.graphics.BitmapFactory;import android.graphics.Matrix;import android.net.Uri;import android.os.Build;import android.provider.DocumentsContract;import android.provider.MediaStore;import androidx.core.content.FileProvider;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.File;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;/** * 图像处理相关工具类 */public class ImageUtils {    /**     * 调用系统相册     *     * @param activity     */    public static void takePhoto(Activity activity, int requestCode) {        Intent intent = takePhoto();        activity.startActivityForResult(Intent.createChooser(intent, "选择图片"), requestCode);    }    public static Intent takePhoto() {        Intent intent = new Intent();        intent.addCategory(Intent.CATEGORY_OPENABLE);        intent.setType("image/*");        //根据版本号不同使用不同的Action        if (Build.VERSION.SDK_INT < 19) {            intent.setAction(Intent.ACTION_GET_CONTENT);        } else {            intent.setAction(Intent.ACTION_OPEN_DOCUMENT);        }        return intent;    }    public static Intent getPhotoIntent() {        Intent intent = new Intent();        intent.addCategory(Intent.CATEGORY_OPENABLE);        intent.setType("image/*");        //根据版本号不同使用不同的Action        if (Build.VERSION.SDK_INT < 19) {            intent.setAction(Intent.ACTION_GET_CONTENT);        } else {            intent.setAction(Intent.ACTION_OPEN_DOCUMENT);        }        return intent;    }    /**     * 调用系统拍照     *     * @param activity     */    public static void takeCamera(Activity activity, String filePath, int requestCode) {        Intent intent = takeCamera(activity, filePath);        activity.startActivityForResult(intent, requestCode);    }    public static Intent takeCamera(Context context, String filePath) {        //跳转到调用系统相机        Intent intent = new Intent(MediaStore.ACTION_IMAGE_CAPTURE);        //判断版本        Uri contentUri;        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.N) {   //如果在Android7.0以上,使用FileProvider获取Uri            intent.setFlags(Intent.FLAG_GRANT_WRITE_URI_PERMISSION);            contentUri = FileProvider.getUriForFile(context, context.getPackageName() + ".fileprovider", new File(filePath));        } else {    //否则使用Uri.fromFile(file)方法获取Uri            contentUri = Uri.fromFile(new File(filePath));        }        intent.putExtra(MediaStore.EXTRA_OUTPUT, contentUri);        return intent;    }    //获取文件的uri    public static Uri getFileUri(Context context, File f) {        Uri contentUri;        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.N) {   //如果在Android7.0以上,使用FileProvider获取Uri            contentUri = FileProvider.getUriForFile(context, context.getPackageName() + ".fileprovider", f);        } else {    //否则使用Uri.fromFile(file)方法获取Uri            contentUri = Uri.fromFile(f);        }        return contentUri;    }    public static String getPicFromPhoto(Context mContext, Intent data) {        String imagePath = null;        //判断手机系统版本号        if (Build.VERSION.SDK_INT >= 19) {            //4.4及以上系统使用这个方法处理图片            Uri uri = data.getData();            if (DocumentsContract.isDocumentUri(mContext, uri)) {                //如果是document类型的Uri,则通过document id处理                String docId = DocumentsContract.getDocumentId(uri);                if ("com.android.providers.media.documents".equals(uri.getAuthority())) {                    String id = docId.split(":")[1];//解析出数字格式的id                    String selection = MediaStore.Images.Media._ID + "=" + id;                    imagePath = getImagePath(mContext, MediaStore.Images.Media.EXTERNAL_CONTENT_URI, selection);                } else if ("com.android.providers.downloads.documents".equals(uri.getAuthority())) {                    Uri contentUri = ContentUris.withAppendedId(Uri.parse("content://downloads/public_downloads"), Long.valueOf(docId));                    imagePath = getImagePath(mContext, contentUri, null);                }            } else if ("content".equalsIgnoreCase(uri.getScheme())) {                //如果是content类型的Uri，则使用普通方式处理                imagePath = getImagePath(mContext, uri, null);            } else if ("file".equalsIgnoreCase(uri.getScheme())) {                //如果是file类型的Uri，直接获取图片路径即可                imagePath = uri.getPath();            }        } else {            //4.4以下系统使用这个放出处理图片            Uri uri = data.getData();            imagePath = getImagePath(mContext, uri, null);        }        return imagePath;    }    /**     * 转换 content:// uri     *     * @param imageFile     * @return     */    public static Uri getImageContentUri(Context mContext, File imageFile) {        String filePath = imageFile.getAbsolutePath();        Cursor cursor = mContext.getContentResolver().query(                MediaStore.Images.Media.EXTERNAL_CONTENT_URI,                new String[]{MediaStore.Images.Media._ID},                MediaStore.Images.Media.DATA + "=? ",                new String[]{filePath}, null);        if (cursor != null && cursor.moveToFirst()) {            int id = cursor.getInt(cursor                    .getColumnIndex(MediaStore.MediaColumns._ID));            Uri baseUri = Uri.parse("content://media/external/images/media");            return Uri.withAppendedPath(baseUri, "" + id);        } else {            if (imageFile.exists()) {                ContentValues values = new ContentValues();                values.put(MediaStore.Images.Media.DATA, filePath);                return mContext.getContentResolver().insert(                        MediaStore.Images.Media.EXTERNAL_CONTENT_URI, values);            } else {                return null;            }        }    }    private static String getImagePath(Context mContext, Uri uri, String selection) {        String path = null;        //通过Uri和selection来获取真实的图片路径        Cursor cursor = mContext.getContentResolver().query(uri, null, selection, null, null);        if (cursor != null) {            if (cursor.moveToFirst()) {                path = cursor.getString(cursor.getColumnIndex(MediaStore.Images.Media.DATA));            }            cursor.close();        }        return path;    }    /**     * 调用系统裁剪     *     * @param uri     * @param imagePath 输出路径     * @param aspectX     * @param aspectY     * @param outputx     * @param outputY     * @return     */    public static Intent takeCut(Uri uri, String imagePath, int aspectX, int aspectY, int outputx, int outputY) {        File f = new File(imagePath);        if (!f.exists()) {            File parentFile = f.getParentFile();            if (!parentFile.exists()) {                parentFile.mkdirs();            }            try {                f.createNewFile();            } catch (IOException e) {                e.printStackTrace();            }        }        Intent intent = new Intent("com.android.camera.action.CROP");        intent.setDataAndType(uri, "image/*");        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.N) {            intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION); //添加这一句表示对目标应用临时授权该Uri所代表的文件        }        // crop为true是设置在开启的intent中设置显示的view可以剪裁        intent.putExtra("crop", "true");        // aspectX aspectY 是宽高的比例        if (aspectX != -1 && aspectY != -1) {            intent.putExtra("aspectX", aspectX);            intent.putExtra("aspectY", aspectY);        }        // outputX,outputY 是剪裁图片的宽高        intent.putExtra("outputX", outputx);        intent.putExtra("outputY", outputY);        intent.putExtra("scale", true);        intent.putExtra("return-data", false);        intent.putExtra("outputFormat", Bitmap.CompressFormat.JPEG.toString());// 返回格式        intent.putExtra("noFaceDetection", true);        intent.putExtra(MediaStore.EXTRA_OUTPUT, Uri.fromFile(new File(imagePath)));// 保存到原文件        return intent;    }    public static Intent takeCutPic(Uri uri, String imagePath, int aspectX, int aspectY) {        File f = new File(imagePath);        if (!f.exists()) {            File parentFile = f.getParentFile();            if (!parentFile.exists()) {                parentFile.mkdirs();            }            try {                f.createNewFile();            } catch (IOException e) {                e.printStackTrace();            }        }        Intent intent = new Intent("com.android.camera.action.CROP");        intent.setDataAndType(uri, "image/*");        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.N) {            intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION); //添加这一句表示对目标应用临时授权该Uri所代表的文件        }        // crop为true是设置在开启的intent中设置显示的view可以剪裁        intent.putExtra("crop", "true");        // aspectX aspectY 是宽高的比例        if (aspectX != -1 && aspectY != -1) {            intent.putExtra("aspectX", aspectX);            intent.putExtra("aspectY", aspectY);        }        intent.putExtra("scale", true);        intent.putExtra("return-data", false);        intent.putExtra("outputFormat", Bitmap.CompressFormat.JPEG.toString());// 返回格式        intent.putExtra("noFaceDetection", true);        intent.putExtra(MediaStore.EXTRA_OUTPUT, Uri.fromFile(new File(imagePath)));// 保存到原文件        return intent;    }    /**     * 保存图像到指定路径     *     * @param bitmap 原始图像     * @param path   保存路径     * @param name   保存名称     */    public void saveBitmap(Bitmap bitmap, String path, String name) {        File f = FileUtils.createFile(path, name);        FileOutputStream fos = null;        try {            fos = new FileOutputStream(f);        } catch (FileNotFoundException e) {            e.printStackTrace();        }        bitmap.compress(Bitmap.CompressFormat.PNG, 100, fos);        try {            fos.flush();        } catch (IOException e) {            e.printStackTrace();        }        try {            fos.close();        } catch (IOException e) {            e.printStackTrace();        }    }    /**     * 从指定路径获取图片，按照指定长宽尺寸获取图片 原理：用流去获取图像，计算得到所需Options，然后用options加载图片。     */    public static Bitmap getBitmapFromPath(String filePath, int size, int reqWidth, int reqHeight) throws IOException {        byte[] buffer = getBitmapFromPathRetByte(filePath, size, reqWidth, reqHeight);        ByteArrayInputStream isBm = new ByteArrayInputStream(buffer);        return BitmapFactory.decodeStream(isBm, null, null);    }    public static byte[] getBitmapFromPathRetByte(String filePath, int size, int reqWidth, int reqHeight) throws IOException {        int width = 0, height = 0;        // 获取原始图片的长和宽        BitmapFactory.Options options = new BitmapFactory.Options();        options.inJustDecodeBounds = true;        BitmapFactory.decodeFile(filePath, options);        int h = options.outHeight;        int w = options.outWidth;        if (w <= 0 || h <= 0) {            throw new IOException("图片已损坏");        }        width = w;        height = h;        //计算压缩比例        int inSampleSize = 1;        if (height > reqHeight || width > reqWidth) {            final int heightRatio = Math.round((float) height / (float) reqHeight);            final int widthRatio = Math.round((float) width / (float) reqWidth);            inSampleSize = heightRatio < widthRatio ? heightRatio : widthRatio;        }        if (inSampleSize <= 0) {            inSampleSize = 1;        }        // 缩放并压缩图片        options.inSampleSize = inSampleSize;        options.inJustDecodeBounds = false;        Bitmap bitmap = BitmapFactory.decodeFile(filePath, options);        Bitmap newBmp = null;        if (bitmap.getWidth() > reqWidth || bitmap.getHeight() > reqHeight) {            newBmp = getScaleBitmap(bitmap, reqWidth, reqHeight);        }        byte[] buffer = null;        if (newBmp != null) {            buffer = compressBitmapRetByte(newBmp, size);        } else {            buffer = compressBitmapRetByte(bitmap, size);        }        return buffer;    }    /**     * 把图片按固定比例缩放,根据宽高比，来取最适合的压缩方式     */    public static Bitmap getScaleBitmap(Bitmap bmp, int width, int height) {        Bitmap newBmp = null;        int imageHeight = bmp.getHeight();        int imageWidth = bmp.getWidth();        float scaleWidth = (float) width / imageWidth;        float scaleHeight = (float) height / imageHeight;        Matrix matrix = new Matrix();        if (scaleWidth >= scaleHeight) {            matrix.postScale(scaleHeight, scaleHeight);        } else {            matrix.postScale(scaleWidth, scaleWidth);        }        newBmp = Bitmap.createBitmap(bmp, 0, 0, imageWidth, imageHeight,                matrix, true);		/*if (!bmp.isRecycled()) {			bmp.recycle();		}*/        return newBmp;    }    /**     * 图像数据大小压缩到指定大小，返回Bitmap     *     * @param bmp  原始图像     * @param size 压缩到的图像数据大小 （单位kb）     * @return     */    public static Bitmap compressBitmapRetBmp(Bitmap bmp, int size) {        byte[] b = compressBitmapRetByte(bmp, size);        ByteArrayInputStream isBm = new ByteArrayInputStream(b);// 把压缩后的数据baos存放到ByteArrayInputStream中        Bitmap bitmap = BitmapFactory.decodeStream(isBm, null, null);// 把ByteArrayInputStream数据生成图片        return bitmap;    }    /**     * 图像数据大小压缩到指定大小，返回字节数组     *     * @param bmp  原始图像     * @param size 压缩到的图像数据大小 （单位kb）     * @return     */    public static byte[] compressBitmapRetByte(Bitmap bmp, int size) {        ByteArrayOutputStream baos = new ByteArrayOutputStream();        bmp.compress(Bitmap.CompressFormat.JPEG, 100, baos);// 质量压缩方法，这里100表示不压缩，把压缩后的数据存放到baos中        int options = 100;        while (baos.toByteArray().length / 1024 > size) { // 循环判断如果压缩后图片是否大于500kb,大于继续压缩            baos.reset();// 重置baos即清空baos            bmp.compress(Bitmap.CompressFormat.JPEG, options, baos);// 这里压缩options%，把压缩后的数据存放到baos中            options -= 10;// 每次都减少10        }        if (!bmp.isRecycled()) {            bmp.recycle();        }        return baos.toByteArray();    }}